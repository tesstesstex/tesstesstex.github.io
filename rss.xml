<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[一身上の都合]]></title><description><![CDATA[作ったものから身の上話まで]]></description><link>https://tesstesstex.vercel.app</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 11 Jun 2021 13:30:03 GMT</lastBuildDate><item><title><![CDATA[YouTube Data API で登録済みチャンネルの中からライブ配信中のものだけ取得しようとしたがQuota の上限に引っかかった]]></title><description><![CDATA[YouTube Data API で何かをつくるにはQuota 制限のせいで実用的なものは難しいかもしれない。]]></description><link>https://tesstesstex.vercel.appmvs_aydhbjt9</link><guid isPermaLink="false">https://tesstesstex.vercel.appmvs_aydhbjt9</guid><pubDate>Sun, 30 May 2021 11:10:32 GMT</pubDate><content:encoded>YouTube 配信開始の通知はGoogle アカウントへのメールか、スマホへのポップアップ通知しかないので、自分でAPI 叩いてDiscord とかに通知飛ばせるようにするかと思いちょっとしたツールを作りました。  


  
が、一つ問題がありGCP のYouTube Data API は一日10,000 Queries というQuota(割当)上限が決められており、さらに使用するAPI によってQueries の使用量が定められています。  
Quota については[公式のドキュメント](https://developers.google.com/youtube/v3/determine_quota_cost)をご確認ください。  
  


例を挙げると、  
チャンネル登録に関するAPI である`subscriptions.list` を使用する場合はcost は &lt;b&gt;&quot;1&quot;&lt;/b&gt; ですが、   
動画を検索する`search.list` を使用する場合はcost は &lt;b&gt;&quot;50&quot;&lt;/b&gt; も必要です。  
  
  

今回やりたかったことは流れとして、  

1. 自分の登録チャンネルのID を取得する  
2. 各チャンネルの配信中の配信があればそれを返す  
3. それをDiscord とかで5分おき(配信開始は大抵キリの良い時間なので)に通知する  

って感じなんですが、YouTube Data API では配信中かどうかの情報は `videos` または `search` リソースでしか取得できません。   
`videos` に関してはChannel ID からは取得できず、`search` リソースを使用するしかないのですが、  
登録チャンネルが50だった場合、`search` のコスト 50 × 50 で2,500 Queries を消費してしまうので課金する他方法がないようです。  
Quota 上限の開放に関しては[個人だと難しいみたい](https://stackoverflow.com/questions/61281991/applying-for-additional-quota-for-youtube-api-as-an-individual-without-business/62686472#62686472)なので、白旗です。  


### 一応作ったものはこちら  
[tesstesstex/stream_now](https://github.com/tesstesstex/stream_now)


</content:encoded></item><item><title><![CDATA[Vue CLI でGoogleAppsScript アプリ を作成するまで]]></title><description><![CDATA[Vue CLI を使用したSPA をWebpack でなんとかGAS 上にデプロイできるようにならないかやってみた ]]></description><link>https://tesstesstex.vercel.appUZl-L_vYqclV</link><guid isPermaLink="false">https://tesstesstex.vercel.appUZl-L_vYqclV</guid><pubDate>Mon, 01 Feb 2021 19:10:32 GMT</pubDate><content:encoded># VueCLI4 でGoogleAppsScript アプリを作成する

GoogleAppsScript (以下GAS) で簡易なWeb サイトやアプリケーションが作成できるのですが、  
それをVueCLI を用いて作成してみました。  

## Vue CLI のインストール

Vue.js のアプリケーションを簡単に作るためのCLI ツールであるVue CLI をインストールします。  
Vue CLI はglobal install する必要があるので注意。  

なおnpm を使用する場合は適宜読み替えてください。  
```
$ yarn global add @vue/cli @vue/cli-init
yarn global v1.22.10
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
[4/4] 🔨  Building fresh packages...
success Installed &quot;@vue/cli@4.5.11&quot; with binaries:
      - vue
✨  Done in 197.86s.

$ vue --version
@vue/cli 4.5.11
```
* vue が動かない場合はグローバルインストールしたパッケージへのパスが通っていないと思われます。必要に応じてググってみてください。  


## プロジェクトを作成

プロジェクト内にすべてのソースコードが入ります。  

```
$ vue create &lt;appname&gt;
* ここではappname は&quot;vue-gas-app&quot; とします。
** おそらくself singed certificate に関するエラーが生じるので、Global Protect を一時的に切断しましょう。
*** 終了後再接続するのを忘れずに。
```

実行後、以下の初期設定用インタラクティブモードに入ります。  
今回は試しにManual で設定してみましょう。 
```
Vue CLI v4.5.11
? Please pick a preset: (Use arrow keys)
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
❯Manually select features
```

```
? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)
❯◉ Choose Vue version
 ◉ Babel
 ◯ TypeScript
 ◯ Progressive Web App (PWA) Support
 ◯ Router
 ◯ Vuex
 ◯ CSS Pre-processors
 ◉ Linter / Formatter
 ◯ Unit Testing
 ◯ E2E Testing
```

```
? Choose a version of Vue.js that you want to start the project with
❯ 2.x
  3.x (Preview)
```

```
? Pick a linter / formatter config:
  ESLint with error prevention only
  ESLint + Airbnb config
  ESLint + Standard config
❯ ESLint + Prettier
```

```
? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)
❯◉ Lint on save
 ◯ Lint and fix on commit
```

```
? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
❯ In dedicated config files
  In package.json
```

```
? Save this as a preset for future projects? (y/N) n
```

```
? Pick the package manager to use when installing dependencies: (Use arrow keys)
❯ Use Yarn
  Use NPM
```

```
✨  Creating project in /Users/user/work/vue-gas-app.
🗃  Initializing git repository...
⚙️  Installing CLI plugins. This might take a while...

yarn install v1.22.10
info No lockfile found.
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
[4/4] 🔨  Building fresh packages...
success Saved lockfile.
✨  Done in 123.97s.
🚀  Invoking generators...
📦  Installing additional dependencies...

yarn install v1.22.10
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
[4/4] 🔨  Building fresh packages...

success Saved lockfile.
✨  Done in 20.69s.
⚓  Running completion hooks...

📄  Generating README.md...

🎉  Successfully created project vue-gas-app.
👉  Get started with the following commands:

 $ cd vue-gas-app
 $ yarn serve
```

今回はVueCLI でデフォルトのビューのみのアプリを作成するので、Vue Router やVuex は使用しないものとします。    
パッケージのインストールが完了したら試しに一度動かしてみましょう。    

```
$ cd vue-app-demo

$ yarn serve
```

## GoogleAppsScript の用意

以下のリンクからGoogle Apps Script API を｢オン｣にしておきましょう。  
https://script.google.com/u/1/home/usersettings  

GAS のソースコードはclasp というCUI ツールによってローカル環境と同期することができます。  

```
$ yarn global add @google/clasp

$ clasp login

$ clasp create vue-gas-app
? Create which script?
  standalone
  docs
  sheets
  slides
  forms
❯ webapp
  api
```

```
Created new webapp script: https://script.google.com/d/&lt;id&gt;/edit
Warning: files in subfolder are not accounted for unless you set a &apos;.claspignore&apos; file.
Cloned 1 file.
└─ appsscript.json
```

ここで新たにappsscript.json と.clasp.json が作成されます。  
最終的にGAS へは`clasp push` というコマンドでdist/ 内のファイルをアップロードするのですが、  
dist/ 内にappsscript.json やCode.js を配置することを避けるために、gas/ というディレクトリを作成しましょう。  

```
$ mkdir gas

$ mv appsscript.json gas/

$ echo .clasp.json &gt;&gt; .gitignore
```

またgas/ 内にGAS のエントリポイントとなるCode.js を作成します。  

```javascript
# Code.js
function doGet() {
  return getHtml()
}
function getHtml() {
  const html = HtmlService.createTemplateFromFile(&apos;index&apos;)
  return html
    .evaluate()
    .setTitle(&apos;vue-gas-app&apos;)
    .addMetaTag(&apos;viewport&apos;, &apos;width=device-width, initial-scale=1&apos;)
}
```

dist/ 内のファイルをGAS へpush するために.clasp.json を以下のように修正します。  

```json
{
  &quot;scriptId&quot;:&quot;&lt;id&gt;&quot;,
  &quot;rootDir&quot;: &quot;dist&quot;
}
```

## ビルドの設定

作成したgas/ 内のファイルをビルドの際にdist/ にコピーしてくれるように、webpack の設定をします。  
VueCLI では従来のようにwebpack.config.js に設定するのではなく、vue.config.js 内に記述します。  

```javascript
# vue.config.js
const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)

module.exports = {
  configureWebpack: {
    plugins: [
      new CopyWebpackPlugin([
        {
          from: path.resolve(__dirname, &apos;./gas&apos;),
          ignore: [&apos;.*&apos;]
        }
      ])
    ]
  }
};
```

また、VueCLI の通常のバンドルではGAS では読み込めない場合があるため、すべてをインラインでバンドルすることにします。

```javascript
# vue.config.js
const path = require(&apos;path&apos;)
const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)
const HtmlWebpackInlineSourcePlugin = require(&apos;html-webpack-inline-source-plugin&apos;)

module.exports = {
  publicPath: &apos;/public&apos;,
  chainWebpack: config =&gt; {
    config
      .plugin(&apos;html&apos;)
      .tap(args =&gt; {
        args[0].template = &apos;./public/index.html&apos;
        args[0].inlineSource = &apos;.(vue|js|css)&apos;
        return args
      })
  },
  configureWebpack: {
    plugins: [
      new HtmlWebpackInlineSourcePlugin(),
      new CopyWebpackPlugin([
        {
          from: path.resolve(__dirname, &apos;./gas&apos;),
          ignore: [&apos;.*&apos;]
        }
      ])
    ]
  }
};
```

## deploy

では実際にビルドしてみましょう。  

```
$ yarn build
```

ビルドしたものをclasp push でデプロイします。  
また、不要なファイルがアップロードされないように事前に.claspignore を設定します。  

```
/* .claspignore */
**/**
static/**
static/css/**
!appsscript.json
!Code.js
!index.html
```

```
$ clasp push
```

これでGAS の画面からデプロイすればOKです。

## Appendix

### Linter とFormatter

Linting rules に関しては好みが分かれますが、ここでは標準的に使用されているPrettier をフォーマッタに使用します。  
VueCLI を使用してESLint + Prettier をインストールすると、自動的にESLint とPrettier で競合するルールをオフにしてくれる`eslint-config-prettier` がインストールされるので、基本的には自分で特にルールをいじる必要はありません。  
私の場合は .prettierrc.js にてシングルクォートのみ有効にしてあります。  

```javascript
# .prettierrc.js
module.exports = {
  singleQuote: true,
};
```
</content:encoded></item><item><title><![CDATA[Hangouts Chatの雨通知botを爆速で作る]]></title><description><![CDATA[Google Chat (旧名: Hangouts Chat) のbot を簡単に作る方法]]></description><link>https://tesstesstex.vercel.app2OsBWeOpgTBV</link><guid isPermaLink="false">https://tesstesstex.vercel.app2OsBWeOpgTBV</guid><pubDate>Thu, 26 Mar 2020 03:15:00 GMT</pubDate><content:encoded>**:warning:この記事は2019/12/06 にQiita に投稿したものです**

@murs313 さんの[Slackの雨通知botを爆速で作る【メッ●●】](https://qiita.com/murs13/items/abc2b124d53e2ed54a02)を読み、
早速同じ物を作ろうと思いましたが、弊社はSlackが使えませんでした。

というわけで**Hangouts Chat版**雨通知botを作ってみました。
GASだと真似しすぎで作っててつまらないのでPythonとcronで実装してみました。

※ なおHangouts ChatはG Suiteでのみ使用でき、個人のGoogleアカウントでは現在使用できません。

# つくったもの
テストで送信してみたものがこちら。
実際は時間を合わせて17:00に送信されるように設定しています。
![IMG_0068.jpg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/342105/da93ccdf-2a24-c9dc-4b94-eb48a3689152.jpeg)
Hangouts ChatはMarkdownっぽい記法が使えるのが良いですね。
（画像では強調表示がうまいこといってませんが……）

# つかったもの
- **CentOS 8**  
  cronで定期実行します。
- **Python 3.6.8**  
- **Hangouts Chat の incoming webhook**
- **[livedoorお天気API](http://weather.livedoor.com/weather_hacks/webservice)**

# Hangouts ChatへのPOST
Hangouts Chat は incoming webhook が使用できます。
@iitenkida7 さんの [[超簡単]Hangouts Chat の incoming webhooks を使ってAPIから簡単にメッセージを投稿する](https://qiita.com/iitenkida7/items/3c8f9f8f6ee1e809558d)を参考にさせて頂きました。

# Pythonのソースコード
```python:weather.py
import requests

weather_url = &apos;http://weather.livedoor.com/forecast/webservice/json/v1?city=130010&apos; # Tokyo
resp = requests.get(weather_url)
data = resp.json()

# 一部ぼかしていますがコピペでおk
webhook_url = &quot;https://chat.googleapis.com/v1/spaces/HOGEHOGE/messages?key={YOUR_KEY}&amp;token={YOUR_TOKEN}&quot; 

tomorrow_weather = data[&apos;forecasts&apos;][1]
telop = tomorrow_weather[&apos;telop&apos;]
max_temp = tomorrow_weather[&apos;temperature&apos;][&apos;max&apos;]
min_temp = tomorrow_weather[&apos;temperature&apos;][&apos;min&apos;]
image = tomorrow_weather[&apos;image&apos;][&apos;url&apos;]

text = &apos;&apos;
text += &apos;明日の天気は&apos;
text += &apos;*&apos; + telop + &apos;*&apos;
text += &apos;です。\n&apos;
# なぜかmaxとminが時々取得できない
if max_temp is not None:
    text += &apos;最高気温&apos;
    text += max_temp.get(&apos;celsius&apos;)
    text += &apos;℃&apos;
if min_temp is not None:
    text += &apos;/最低気温&apos;
    text += min_temp.get(&apos;celsius&apos;)
    text += &apos;℃\n&apos;
text += image

content = {&quot;text&quot;: text}
response = requests.post(webhook_url, json=content)
```

# cronの設定
cronの設定は[こちら](https://eng-entrance.com/linux-command-crontab)が参考になると思います。

cronの設定を行うには```crontab -e```を叩きましょう。

```sh
$ crontab -e
```

するとVimで設定ファイルが開くので、実行する時間と実行するコマンドを入力しましょう。
今回はホームディレクトリ直下に置いたという設定です。

```vim
0 17 * * * python3 ~/weather.py
```

ファイルを保存してVimを閉じた時に```crontab: installing new crontab```と表示されれば設定完了です。

動作確認する場合は、再度```crontab -e```を開き、

```vim
*/1 * * * * python3 ~/weather.py
```

のように記述すれば1分おきにコマンドが実行されるようになります。

# 感想
参考にさせていただいたリンクがわかりやすかったので特に詰まることなく設定できました。
</content:encoded></item></channel></rss>